@node Sync
@unnumbered Synchronization protocol

So-called synchronization protocol (SP) is used in current TCP daemon's
implementation. It is used for synchronizing @ref{Spool, spool}
directory contents between two nodes.

It is aimed to be very simple and effective. It uses reliable transport
like TCP connections. It must be effective both on single-duplex and
full-duplex links: for example satellites have very high throughput but
high-delay links, so acknowledging of each received packet, like
@url{https://en.wikipedia.org/wiki/XMODEM, XMODEM} does, causes
unacceptable performance degradation.

SP works on top of
@url{http://noiseprotocol.org/noise.html#interactive-patterns,
@code{Noise_IK_25519_ChaChaPoly_BLAKE2b}} protocol. Each Noise packet
are sent inside XDR envelope:

@verbatim
+-----------------+
| MAGIC | PAYLOAD |
+-----------------+
@end verbatim

@multitable @columnfractions 0.2 0.3 0.5
@headitem  @tab XDR type @tab Value
@item Magic number @tab
    8-byte, fixed length opaque data @tab
    @verb{|NNCPS0x00x00x01|}
@item Payload @tab
    variable length opaque data @tab
    Noise packet itself
@end multitable

Peers static keys are specified as @ref{Configuration, @emph{noisepub}}
configuration entry.

Payload inside Noise packets has maximum size of @emph{65 KiB - 256 B =
65280 B}. It is sent immediately in the first message by each side. The
very first payload (that is carried inside handshake messages) is always
padded to the maximum size with @emph{HALT} packets (read below), for
hiding actual number of @emph{INFO} packets (number of files available
for transmission).

Each SP payload is a concatenation of SP packets. Each packet has
XDR-encoded header and then corresponding XDR-encoded body. Header is
just an unsigned integer telling what body structure follows.

@table @emph

@item HALT
    Stop file transmission, empty sending queue on the remote side.
    Actually @emph{HALT} packet does not have any body, only the header
    with the type. It is also used in the first payload for padding to
    the maximum size.
@verbatim
+------+
| HALT |
+------+
@end verbatim

@item INFO
    Information about the file we have for transmission.
@verbatim
+------+--------------------+
| INFO | NICE | SIZE | HASH |
+------+--------------------+
@end verbatim
    @multitable @columnfractions 0.2 0.3 0.5
    @headitem  @tab XDR type @tab Value
    @item Niceness @tab
        unsigned integer @tab
        1-255, file niceness level
    @item Size @tab
        unsigned hyper integer @tab
        File size
    @item Hash @tab
        32-byte, fixed length opaque data @tab
        Unique file identifier, its checksum
    @end multitable

@item FREQ
    File transmission request. Ask remote side to queue the file for
    transmission.
@verbatim
+------+---------------+
| FREQ | HASH | OFFSET |
+------+---------------+
@end verbatim
    @multitable @columnfractions 0.2 0.3 0.5
    @headitem  @tab XDR type @tab Value
    @item Hash @tab
        32-byte, fixed length opaque data @tab
        Unique file identifier, its checksum
    @item Offset @tab
        unsigned hyper integer @tab
        Offset from which remote side must transmit the file
    @end multitable

@item FILE
    Chunk of file.
@verbatim
+------+-------------------------+
| FILE | HASH | OFFSET | PAYLOAD |
+------+-------------------------+
@end verbatim
    @multitable @columnfractions 0.2 0.3 0.5
    @headitem  @tab XDR type @tab Value
    @item Hash @tab
        32-byte, fixed length opaque data @tab
        Unique file identifier, its checksum
    @item Offset @tab
        unsigned hyper integer @tab
        Offset from which transmission goes
    @item Payload @tab
        variable length opaque data @tab
        Chunk of file itself
    @end multitable

@item DONE
    Signal remote side that we have successfully downloaded the file.
@verbatim
+------+------+
| DONE | HASH |
+------+------+
@end verbatim
    @multitable @columnfractions 0.2 0.3 0.5
    @headitem  @tab XDR type @tab Value
    @item Hash @tab
        32-byte, fixed length opaque data @tab
        Unique file identifier, its checksum
    @end multitable

@end table

Typical peers behaviour is following:

@enumerate
@item Perform Noise-IK handshake.
@item When remote peer's identity is known (by definition for initiator
and after receiving first packet for responser (however it is not
authenticated yet)), then collect all @emph{tx}-related files
information and prepare payload packets with all that @emph{INFO}s.
@item Pad the very first payload packet (that is sent with first Noise
handshake message) with @emph{HALT}s to the maximal size.
@item Send all queued payload packets.
@item When @emph{INFO} packet received, check that is has an acceptable
niceness level (skip if not), check if file's @file{.part} exists and
queue @emph{FREQ} outgoing packet (with corresponding offset if
required).
@item When @emph{FREQ} packet received, append it to current sending
queue. Sending queue contains files with offsets that are needed to be
sent.
@item While sending queue is not empty, send @emph{FILE} packet until
queue's head is not fully sent. @emph{FREQ} can contain offset equal to
size -- anyway sent @emph{FILE} packet with an empty payload.
@item When @emph{FILE} packet received, check if it is not fully
downloaded (comparing to @emph{INFO}'s packet information). If so, then
run background integrity checker on it. If check is succeeded, then
delete @file{.part} suffix from file's name and send @emph{DONE} packet.
@item When @emph{DONE} packet received, delete corresponding file.
@item When @emph{HALT} packet received, empty file sending queue.
@item @emph{FILE} sending is performed only if no other outgoing packets
are queued.
@item Each second node check are there any new @emph{tx} packets
appeared and queues corresponding @emph{INFO} packets.
@item If no packets are sent and received during @ref{Onlinedeadline,
onlinedeadline} duration, then close the connection. There is no
explicit indication that session is over.
@end enumerate
